---
title: "ImmuneSignatures 2 Project - Data Preprocessing for Analysis"
author: "Evan Henrich"
date: "April 1, 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, include = FALSE)
```

```{r load-dependencies}
library(ImmuneSignatures2) # vaccine map loaded as `vaccines`
library(ImmuneSpaceR) 
library(Rlabkey)
library(Biobase)
library(data.table)
library(titer) # devtools::install_github("stefanavey/titer")
library(massiR)
library(biomaRt)
library(limma)
```

```{r output-variables}
outputDir <- "/home/ehenrich/"
timeStamp <- "2020_04_01_"
prefix <- paste0(outputDir, timeStamp)
generateTestPlots <- FALSE
```

```{r global-variables}
ageCutoff <- 60

studies <- c("SDY56, SDY61, SDY63, SDY67, SDY80, SDY180, SDY212, SDY224, SDY269, SDY270, SDY400, SDY404, SDY520, SDY640, SDY984, SDY1119, SDY1260, SDY1264, SDY1276, SDY1289, SDY1291, SDY1293, SDY1294, SDY1325, SDY1364, SDY1368, SDY1370, SDY1373")
studies <- strsplit(studies, ", ")[[1]]

con <- CreateConnection("", onTest = TRUE)
```

```{r load-meta-data}
demographics <- con$getDataset("demographics")
geneExpressionFiles <- con$getDataset("gene_expression_files", original_view = TRUE)
featureAnnotationMap <- getTable(con, "microarray", "fasMap", showHidden = TRUE)
featureAnnotation <- getTable(con, "microarray", "FeatureAnnotationSet", showHidden = TRUE)
```

```{r map-meta-data-shared-GE-and-response}
sharedMetaData <- addStudy(demographics)
sharedMetaData <- addArmAccession(sharedMetaData, geneExpressionFiles)
sharedMetaData <- addVaccineFields(sharedMetaData, vaccines)
sharedMetaData <- filterOutNoVaccineSamples(sharedMetaData)
sharedMetaData <- imputeAge(sharedMetaData)
```

# IMMUNE RESPONSE

```{r prepare-immune-response-data}
assays <- c("hai", "neut_ab_titer", "elisa")
immdata_all <- sapply(assays, USE.NAMES = TRUE, function(assay){
  dt <- getImmuneResponseData(assay, con, studies)
  dt$assay <- assay
  dt <- correctHrs(dt)
  dt <- createUniqueIdColumn(dt)
  dt <- merge(dt, sharedMetaData, by = c("participant_id", "study_accession", "arm_accession"))
})
```


```{r split-immune-response-data-into-age-cohorts}
immdataFiltered <- list()
immdataFiltered$young <- filterImmdataByAge(immdata_all, ageCutoff, isYoung = TRUE)
immdataFiltered$older <- filterImmdataByAge(immdata_all, ageCutoff, isYoung = FALSE)
```


```{r generate-response-calls}
postVaxDayRanges <- list(
  hai = c(20,46),
  neut_ab_titer = c(28,90),
  elisa = c(30,30),
  elispot = NA
)

discretizationValues <- list(
    "RBA" = c(0.3, 0.4, 0.5),
    "MFC" = c(0.3, 0.4)
)

immdataWithResponses <- lapply(immdataFiltered, function(immdata_age_group){
  immdata_age_group <- sapply(names(immdata_age_group), USE.NAMES = TRUE, function(assay){
    dataWithResponses <- generateResponseCall(
      assay = assay,
      data = immdata_age_group[[assay]],
      postVaxDayRange = postVaxDayRanges[[assay]],
      discretizationValues = discretizationValues,
      ageCutoff = ageCutoff
    )
  })
})
```

```{r select-response-to-use-per-subject}
selectedImmdata <- lapply(immdataWithResponses, function(immdata_age_group){
  dt <- selectResponsesToUse(immdata_age_group)
})
```

```{r test-immune-response-data}
results <- testImmuneResponseData(selectedImmdata)

if(!all(unlist(results))){
  stop("Immune Response Data is Invalid. Correct and re-run.")
}
```

# GENE EXPRESSION

```{r extract-within-study-normalized-gene-expression-data}
# gene expression matrices in ImmuneSpace are done on a cohort*cell_type basis
# and each matrix is normalized separately.  With a global CreateConnection object
# we start with all available matrices.
geMatrices <- con$cache$GE_matrices
studies <- studies[1:3]
geMatrices <- geMatrices[ geMatrices$folder %in% studies, ]

# Removing cohorts:
# SDY1370 - BCell and TCell, since others are PBMC / WholeBlood
# SDY1325 - lowdose and subcutaenous PS, different vaccine method not related
# SDY1364 - intraDermal, different vaccination method
# SDY180 - Saline cohorts did not receive stimulation
rmCohorts <- "cell|Subcutaneous|LowIntraMuscular|IntraDermal|Saline"
geMatrices <- geMatrices[ grep( rmCohorts, geMatrices$name, invert = TRUE), ] 

esets <- lapply(
  geMatrices$name,
  con$getGEMatrix,
  outputType = "normalized",
  annotation = "latest")
names(esets) <- geMatrices$name
```

```{r check-extracted-ge-data}
results <- testExtractedGEData(esets)

if( !all(unlist(results)) ){
    stop("Normalized matrices do not meet dim and NA value expectations")
}
```

```{r remove-unused-samples-from-esets-pre-summarization}
esets <- lapply(esets, function(eset){
  pData(eset) <- addStudy(pData(eset))
  return(eset)
})

# SDY1325 - Day 35, 7 days post booster but no day 28 data to create new baseline
esets <- removeTimepointFromEset(esets, "SDY1325", 35)

# SDY1293 - Day 0, using last vaccination on Day 60 as new Day 0
esets <- removeTimepointFromEset(esets, "SDY1293", 0)

# SDY180 - Hourly data generates non-matching duplicates for early timepoints
esets <- removeTimepointFromEset(esets, "SDY180", "Hours")

# Study authors of SDY212 cannot explain why one sample is missing some data
esets <- removeSDY212MissingSample(esets)

esets <- lapply(esets, function(eset){
  pd <- pData(eset)
  pd <- correctHrs(pd)
  pd <- addTimePostLastVax(pd)
  pData(eset) <- pd
  eset <- removeSubjectsWithoutBaseline(eset)
})
```

```{r prepare-gene-expression-meta-data}
phenoDataSets <- lapply(esets, pData)
phenoDataSets <- addMatrixRelatedFields(phenoDataSets, geMatrices)

geMetaData <- rbindlist(phenoDataSets)

# Adds vaccine and age_imputed
geMetaData <- merge(geMetaData, sharedMetaData, 
                    by = c("participant_id", "cohort", "study_accession"))

geMetaData <- addFeatureAnnotationSetName(geMetaData, featureAnnotationMap)
geMetaData <- addFeatureAnnotationSetVendor(geMetaData, featureAnnotation)
geMetaData <- addGSMAccessions(geMetaData, geneExpressionFiles)
geMetaData <- createUniqueIdColumn(geMetaData)
geMetaData <- addAnalysisVariables(geMetaData)
geMetaData <- subsetToOnlyNeededColumns(geMetaData)
```

```{r fix-yale-studies-study-time-collected}
geMetaData$time_post_last_vax <- as.numeric(geMetaData$time_post_last_vax)
geMetaData <- updateStudyTimepoints(geMetaData, c("SDY400", "SDY404", "SDY520", "SDY63"), 24, 28)
geMetaData <- updateStudyTimepoints(geMetaData, c("SDY400", "SDY404", "SDY520"), 3, 2)
geMetaData <- updateStudyTimepoints(geMetaData, c("SDY400", "SDY404", "SDY520"), 8, 7)
geMetaData <- updateStudyTimepoints(geMetaData, c("SDY400", "SDY404", "SDY520"), 9, 7)
geMetaData <- updateStudyTimepoints(geMetaData, c("SDY63"), 5, 4)
```

```{r summarize-gene-expression-data-by-gene-symbol}
summarizedEsets <- summarizeByGeneSymbol(esets)

allGE <- Reduce(f = function(x, y){ merge(x, y, by = "gs", all = TRUE)},
                summarizedEsets)
gs <- allGE$gs
allGE[, gs := NULL ]
```


```{r match-ge-and-metadata}
geMetaData <- geMetaData[ order(match(geMetaData$biosample_accession, colnames(allGE))), ]
if (!all.equal(geMetaData$biosample_accession, colnames(allGE))) {
    stop("biosample accessions do NOT match for expression data and meta-data!")
}
colnames(allGE) <- c(geMetaData$uid)
allGE[, rn := gs]
```

```{r pre-norm-gene-expression-tests}
exprDataResults <- testAllGEMatrixPreNorm(allGE)
metaDataResults <- testAllGEMetaDataPreNorm(geMetaData)
if(!all(unlist(c(exprDataResults, metaDataResults)))){
  stop("Not all pre-norm checks are passing!")
}
```

```{r create-initial-expression-set}
geMetaData <- as.data.frame(geMetaData)
rownames(geMetaData) <- geMetaData$uid
noNormEset <- new("ExpressionSet", 
                   exprs = as.matrix(allGE, rownames = "rn"),
                   phenoData = new('AnnotatedDataFrame', 
                               geMetaData))
noNormEset <- imputeGender(noNormEset)
```

```{r split-gene-expression-data-into-age-cohorts}
# Wait until after summarization so that we know that both age cohorts are using same probes
esets <- list(noResponse = list(noNorm = list()))
esets$noResponse$noNorm$young <- noNormEset[ , noNormEset$age_imputed < ageCutoff ]
esets$noResponse$noNorm$older <- noNormEset[ , noNormEset$age_imputed >= ageCutoff ]
```

```{r cross-study-normalization-and-batch-correction}
esets$noResponse$norm <- lapply(esets$noResponse$noNorm, function(eset){
  eset <- crossStudyNormalize(eset, vendorToUse = "Affymetrix", studiesToExclude = "SDY1293")
  eset <- addCoalescedFeatureSetName(eset)
  eset <- batchCorrectBaselineData(eset)
  if(generateTestPlots){
    generateSampleMDSplot(eset, numberOfSamples = 8)
  }
})
```

```{r add-response-data}
esets$withResponse <- sapply(names(esets$noResponse), 
                             function(normStatus){
                             noResponseEsets <- esets$noResponse[[normStatus]]
                             withResponseEsets <- sapply(names(noResponseEsets), 
                                                         addResponseData, 
                                                         noResponseEsets,
                                                         selectedImmdata,
                                                         USE.NAMES = TRUE)
                             },
                             USE.NAMES = TRUE,
                             simplify = FALSE
)
```

```{r test-final-esets}
results <- list()
for(responseStatus in names(esets)){
  for(normStatus in names(esets[[responseStatus]])){
    for(ageCohort in names(esets[[responseStatus]][[normStatus]])){
      eset <- esets[[responseStatus]][[normStatus]][[ageCohort]]
      name <- paste(responseStatus, normStatus, ageCohort, sep = "_")
      results[name] <- testFinalEset(eset,
                                     responseStatus,
                                     ageCohort,
                                     ageCutoff)
    }
  }
}

if(!all(unlist(results))){
  stop("Final esets are malformed.")
}
```

```{r output}
save(immdata, file = paste0(prefix, "IS2_immdata.rda"))
save(esets, file = paste0(prefix, "IS2_esets.rda"))

IS2_session_info <- sessionInfo()
save(IS2_session_info, file = paste0(prefix, "IS2_session_info.rda"))d
```
