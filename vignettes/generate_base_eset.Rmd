---
title: "ImmuneSignatures2: Generating Base ExpressionSet from ImmuneSpace Data"
author: "Evan Henrich"
output: html_document
---

# Overview
The purpose of this vignette is to generate a base expressionSet object with transcriptomic and immune response data for a number of studies from the ImmuneSpace portal, www.immunespace.org.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, include = FALSE)
```

```{r load-dependencies}
library(ImmuneSignatures2) # vaccine map loaded as `vaccines`
library(ImmuneSpaceR) 
library(Rlabkey)
library(Biobase)
library(dplyr)
library(data.table)
library(limma)
library(tidyverse)
```

```{r output-variables}
outputDir <- "outputs/"
dataCacheDir <- "data_cache/"
if (!dir.exists(outputDir)) dir.create(outputDir)
if (!dir.exists(dataCacheDir)) dir.create(dataCacheDir)
timeStamp <- "2020_12_23_newAnno_"
```

The ImmuneSignatures group selected a number of studies based on the diseases studied, study design and data availability.  For some studies there were cohorts that were excluded due to different vaccination methods, lack of stimulation, or different cell types.

```{r global-variables}
studies <- c("SDY56, SDY61, SDY63, SDY67, SDY80, SDY180, SDY212, SDY224, SDY269, SDY270, SDY400, SDY404, SDY520, SDY640, SDY984, SDY1119, SDY1260, SDY1264, SDY1276, SDY1289, SDY1291, SDY1293, SDY1294, SDY1325, SDY1328, SDY1364, SDY1368, SDY1370, SDY1373, SDY1529")
studies <- strsplit(studies, ", ")[[1]]

# Removing cohorts from gene expression data:
# SDY1370 - BCell and TCell, since others are PBMC / WholeBlood
# SDY1325 - lowdose and subcutaenous PS, different vaccine method not related
# SDY1364 - intraDermal, different vaccination method
# SDY180 - Saline cohorts did not receive stimulation
rmCohorts <- "cell|Subcutaneous|LowIntraMuscular|IntraDermal|Saline"

assays <- c("hai", "neut_ab_titer", "elisa")

con <- CreateConnection("", onTest = TRUE)
```

```{r load-meta-data}
demographics <- con$getDataset("demographics")
geneExpressionFiles <- con$getDataset("gene_expression_files", original_view = TRUE)
featureAnnotationMap <- getTable(con, "microarray", "fasMap", showHidden = TRUE)
featureAnnotation <- getTable(con, "microarray", "FeatureAnnotationSet", showHidden = TRUE)
```

```{r map-meta-data-shared-GE-and-response}
sharedMetaData <- addStudy(demographics)
sharedMetaData <- addArmAccession(sharedMetaData, geneExpressionFiles)
sharedMetaData <- addVaccineFields(sharedMetaData, vaccines)
sharedMetaData <- filterOutNoVaccineSamples(sharedMetaData)
sharedMetaData <- addGeBatchName(sharedMetaData)
sharedMetaData <- addIrpBatchName(sharedMetaData)
sharedMetaData <- addSDY1325metadata(sharedMetaData)
sharedMetaData <- imputeAge(sharedMetaData)
```

# Immune Response Data Retrieval

```{r prepare-immune-response-data}
immdata_all <- sapply(assays, USE.NAMES = TRUE, function(assay){
  dt <- getImmuneResponseData(assay, con, studies)
  if(assay == "elisa"){
    dt <- rbind(dt, sdy1370_elisa)
  }
  dt$assay <- assay
  dt <- correctHrs(dt)
  dt <- createUniqueIdColumn(dt)
  dt <- merge(dt, sharedMetaData, by = c("participant_id", "study_accession", "arm_accession"))
})
saveRDS(immdata_all, file = paste0(dataCacheDir, timeStamp, "immdata_all.rds"))
```

# Gene Expression Data Retrieval
Gene expression matrices in ImmuneSpace are created on a cohort*cell_type basis
and each matrix is quantile normalized and log-transformed separately. The .rds file that contains the list of expressionSets needed for downstream analysis is approximately 1GB and is therefore cached.

```{r extract-within-study-normalized-gene-expression-data}
# With a global CreateConnection object we start with all available matrices.
geMatrices <- con$cache$GE_matrices
geMatrices <- geMatrices[ geMatrices$folder %in% studies, ]
geMatrices <- geMatrices[ grep( rmCohorts, geMatrices$name, invert = TRUE), ] 

esetsFile <- list.files(path = dataCacheDir, pattern = paste0(timeStamp, "IS2_esets.rds"), full.names = TRUE)
if(length(esetsFile) == 0){
  esets <- lapply(
    geMatrices$name,
    con$getGEMatrix,
    outputType = "normalized",
    annotation = "latest")
  names(esets) <- geMatrices$name
  esetsFile <- paste0(dataCacheDir, timeStamp, "IS2_esets.rds")
  saveRDS(esets, file = esetsFile)
}else{
  esets <- readRDS(esetsFile)
}
```

```{r check-extracted-ge-data}
results <- testExtractedGEData(esets)

if( !all(unlist(results)) ){
    stop("Normalized matrices do not meet dim and NA value expectations")
}
```

There are some samples that are removed prior to the summarization of the transcriptomic data from the probe level to the gene symbol level.  The reason for removal is noted for each study.

```{r remove-unused-samples-from-esets-pre-summarization}
esets <- lapply(esets, function(eset){
  pData(eset) <- addStudy(pData(eset))
  return(eset)
})

# SDY1325 - Day 35, 7 days post booster but no day 28 data to create new baseline
esets <- removeTimepointFromEset(esets, "SDY1325", 35)

# SDY1293 - Day 0, using last vaccination on Day 60 as new Day 0
esets <- removeTimepointFromEset(esets, "SDY1293", 0)

# SDY180 - Hourly data generates non-matching duplicates for early timepoints
esets <- removeTimepointFromEset(esets, "SDY180", "Hours")

# Study authors of SDY212 cannot explain why one sample is missing some data
esets <- removeSDY212MissingSample(esets)

esets <- lapply(esets, function(eset){
  pd <- pData(eset)
  pd <- correctHrs(pd)
  pd <- addTimePostLastVax(pd)
  pData(eset) <- pd
  return(eset)
})
```


```{r prepare-gene-expression-meta-data}
phenoDataSets <- lapply(esets, pData)
phenoDataSets <- addMatrixRelatedFields(phenoDataSets, geMatrices)

geMetaData <- rbindlist(phenoDataSets)

# Adds vaccine and age_imputed
geMetaData <- merge(geMetaData, sharedMetaData, 
                    by = c("participant_id", "cohort", "study_accession"))

geMetaData <- addFeatureAnnotationSetName(geMetaData, featureAnnotationMap)
geMetaData <- addFeatureAnnotationSetVendor(geMetaData, featureAnnotation)
geMetaData <- addCoalescedFeatureSetName(geMetaData)
geMetaData <- addGSMAccessions(geMetaData, geneExpressionFiles)
geMetaData <- createUniqueIdColumn(geMetaData)
geMetaData <- addAnalysisVariables(geMetaData)
geMetaData <- subsetToOnlyNeededColumns(geMetaData)
```

A subset of studies created by HIPC collaborators at Yale University have "study_time_collected" values that do not align with the intended "visit_day" value.  These are manually corrected here.

```{r fix-yale-studies-study-time-collected}
geMetaData$time_post_last_vax <- as.numeric(geMetaData$time_post_last_vax)
geMetaData <- updateStudyTimepoints(geMetaData, c("SDY400", "SDY404", "SDY520", "SDY63", "SDY640"), 24, 28)
geMetaData <- updateStudyTimepoints(geMetaData, c("SDY400", "SDY404", "SDY520"), 3, 2)
geMetaData <- updateStudyTimepoints(geMetaData, c("SDY400", "SDY404", "SDY520"), 8, 7)
geMetaData <- updateStudyTimepoints(geMetaData, c("SDY400", "SDY404", "SDY520"), 9, 7)
geMetaData <- updateStudyTimepoints(geMetaData, c("SDY63"), 5, 4)
```

```{r test-ge-metadata-pre-summarization}
metaDataResults <- testGEMetaDataPreSummarization(geMetaData)
if(!metaDataResults){
  stop("Not all pre-summarization checks are passing!")
}
```

Gene expression data is summarized from the probe level (for microarray data) and gene-alias level (RNAseq) to the canonical Gene-Symbol level using mappings from the Human Gene Ontology Network (HUGO).  The probes / gene-aliases are summarized by selecting the probe or gene-alias with the maximum mean value (no log transformation) across all samples within the matrix (cohort * cell_type).

```{r summarize-gene-expression-data-by-gene-symbol}
summarizedEsets <- summarizeByGeneSymbol(esets)

allGE <- Reduce(f = function(x, y){ merge(x, y, by = "gs", all = TRUE)},
                summarizedEsets)
gs <- allGE$gs
allGE[, gs := NULL ]
```

```{r match-ge-and-metadata}
geMetaData <- geMetaData[ order(match(geMetaData$biosample_accession, colnames(allGE))), ]
if (!all.equal(geMetaData$biosample_accession, colnames(allGE))) {
    stop("biosample accessions do NOT match for expression data and meta-data!")
}
colnames(allGE) <- c(geMetaData$uid)
allGE[, rn := gs ]
```

```{r pre-norm-gene-expression-tests}
exprDataResults <- testAllGEMatrixPreNorm(allGE)
metaDataResults <- testAllGEMetaDataPreNorm(geMetaData)

if(!all(unlist(c(exprDataResults, metaDataResults)))){
  stop("Not all pre-norm checks are passing!")
}
```

```{r create-initial-expression-set}
geMetaData <- as.data.frame(geMetaData)
rownames(geMetaData) <- geMetaData$uid
noNormEset <- new("ExpressionSet", 
                   exprs = as.matrix(allGE, rownames = "rn"),
                   phenoData = new('AnnotatedDataFrame', 
                               geMetaData))

noNormEset <- removeSubjectsWithoutBaseline(noNormEset)
```

Gender imputation is performed by using Y-Chromosome associated genes to cluster each cohort into two groups and then assigning groups to either male or female based on the male group having a higher mean expression value for selected genes.  Due to some outliers with extreme values, the Y-chromosome gene expression values are mapped to a lower two-dimensional representation first before clustering.

```{r gender-imputation, include=TRUE}
allMatricesPlot <- qualityControl.genderByMatrix(noNormEset)
pdf(file = file.path(outputDir, paste0(timeStamp, "baseEset_preGenderImpute.pdf")),
    width = 8.5,
    height = 11)
allMatricesPlot
dev.off()

# The following code assigns probable gender based on clustering
# of samples given expression values for 13 Y-Chromosome genes.
noNormEset <- imputeGender.useAllTimepoints(noNormEset)

# Specific samples for SDY1370 were determined to be problematic by
# looking at the coordination of gender_imputed by timepoint
problemSamples <- c("SUB192192.1370,","SUB192199.1370")
noNormEset <- adjustProblemSamples(noNormEset, problemSamples)

failedGenderQC <- qualityControl.failedGenderImputation(noNormEset)
pdf(file = file.path(outputDir, paste0(timeStamp, "baseEset_failedGenderQCAllSubjects.pdf")),
    width = 8.5,
    height = 11)
failedGenderQC
dev.off()


problemSamples <- noNormEset[ , noNormEset$failedGenderQC]
problemSubjectsPlot <- qualityControl.genderImputedByMatrix(problemSamples, 
                                                     returnObject = "probSubjects")
pdf(file = file.path(outputDir, paste0(timeStamp, "baseEset_failedGenderQCproblemSubjects.pdf")),
    width = 8.5,
    height = 11)
problemSubjectsPlot
dev.off()


probStudiesBySubjectTbl <- qualityControl.createSubjectsByStudyTable(problemSamples$participant_id)
data.frame(probStudiesBySubjectTbl)
```

```{r test-non-normalized-expression-set}
res <- testNoNormEset(noNormEset)
if(!all(unlist(res))){
  stop("noNormEset does not meet expectations")
}
saveRDS(noNormEset, file = paste0(dataCacheDir, timeStamp, "noNormEset.rds"))
```
