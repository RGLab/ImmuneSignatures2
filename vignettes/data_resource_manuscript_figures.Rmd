---
title: "ImmuneSignatures2: Reproduction of figures for Data Resource Manuscript"
output: 
  html_document: 
    toc: true
    toc_float: true
    df_print: paged
    code_folding: hide
date: "`r format(Sys.time(), '%d %B, %Y')`"
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      message = FALSE,
                      warning = FALSE)
```


# SETUP
```{r, libraries}
suppressPackageStartupMessages({
  library(package = "knitr")
  library(package = "Biobase")
  library(package = "RColorBrewer")
  library(package = "dplyr")
  library(package = "ggbeeswarm")
  library(package = "pvca") # dleelab/pvca
  library(package = "lme4")
  library(package = "cluster")
  library(package = "ComplexHeatmap") # Bioc Install
  library(package = "ImmuneSignatures2")
  library(package = "patchwork")
  library(package = "stringr")
  library(package = "ggplot2")
  library(package = "here")
  
  # For calculating QC metrics
  library(package = "arrayQualityMetrics") # Bioc install
  
  # Needed for venn diagram
  library(package = "venn")
  library(package = "ggpolypath")
  library(package = "pheatmap")
})
```


```{r, global-variables, echo=FALSE}
dataCacheDir <- here("data_cache", "2021_03_08")
datePrefix <- "2021_03_08_"
```

These figures only look at the "Young" cohort that is defined as 18 to 50 years old and the "Extended Old" cohort of 50 to 90 years old.  The "Old" cohort (not used here) was 60 to 90 years old.
```{r, read-esets}
noRespGEFile <- file.path(dataCacheDir, paste0(datePrefix,"extendedOld_norm_batchCorrectedFromYoung_eset.rds"))
old.NoResp <- readRDS(file = noRespGEFile)


noRespGEFile <- file.path(dataCacheDir, paste0(datePrefix,"young_norm_eset.rds"))
young.NoResp <- readRDS(file = noRespGEFile)

withRespGEFile <- file.path(dataCacheDir, paste0(datePrefix,"young_norm_withResponse_eset.rds"))
young.WithResp <- readRDS(file = withRespGEFile)

all.noResp <- readRDS(file.path(dataCacheDir, paste0(datePrefix, "all_norm_eset.rds")))
all.noResp$featureSetVendor <- ifelse(all.noResp$featureSetVendor == "NA", "RNAseq", all.noResp$featureSetVendor)
all.noNorm <- readRDS(file.path(dataCacheDir, paste0(datePrefix, "all_noNorm_eset.rds")))
all.noNorm$featureSetVendor <- ifelse(all.noNorm$featureSetVendor == "NA", "RNAseq", all.noNorm$featureSetVendor)
```

```{r, set-standard-colors, echo=FALSE}
# Fig 1
set3colors <- brewer.pal("Set3", n = 12)
colors.fig1a <- c(set3colors[c(2, 11, 3, 12, 8)], 
                "black", 
                set3colors[c(7, 6, 5, 1, 4, 9, 10)])

# Other Figures
getPalette <- colorRampPalette(c(brewer.pal(name = "Set3", n = 10),
				                         brewer.pal(name = "Dark2", n = 4)))
vaccines <- unique(paste0(young.NoResp$pathogen, 
                          " (", young.NoResp$vaccine_type, ")"))
vaccine2color <- getPalette(n = length(vaccines)) %>%
  setNames(nm = sort(vaccines))
```

# FIGURES

## Figure 1

### A: 
Array Quality Metrics

```{r array-quality}
arrayQualityPath <- file.path(dataCacheDir, "arrayQualityMetrics")
arrayQualityResultsPath <- file.path(arrayQualityPath, "qc_results.rds")
if (file.exists(arrayQualityResultsPath)) {
  qc_list <- readRDS(arrayQualityResultsPath)
} else {
  if (!dir.exists(arrayQualityPath)) dir.create(arrayQualityPath)
  studies <- unique(all.noNorm$study_accession)
  getQCTable <- function(sdy) {
    # make directory for output for sdy i 
    sdy_path = file.path(dataCacheDir, sdy) 
    if (!dir.exists(sdy_path)) dir.create(sdy_path)
    print(paste0(sdy, ": writing qc to ",  sdy_path))
    
    # subset to SDY acession 
    array = all.noNorm[ , all.noNorm$study_accession == sdy]
    
    # run AQM on sdy and save outlier table. 
    qc = arrayQualityMetrics(expressionset = array, 
                             outdir = sdy_path, 
                             intgroup = c("matrix", "time_post_last_vax"),
                             force = TRUE, 
                             spatial = FALSE,
                             do.logtransform = FALSE)
    if(!is.null(qc$arrayTable)){
      return(qc$arrayTable)
    } else { 
      return(paste0("no report table for ", sdy ))
    }
  }
  qc_list <- lapply(studies, getQCTable)
  saveRDS(qc_list, arrayQualityResultsPath)
}


qc.table.names = c( "abs_mean_distance","KS_signal_intensity","D_MAplot")
qc_df = bind_rows(qc_list)
colnames(qc_df)[3:5] = qc.table.names
write_delim(qc_df, path = paste0(arrayQualityPath,"qc_metadata.txt"), delim = "\t") 

change_x = function(x){ if_else(x == "x", 1 ,false =  0)}
qc_df = qc_df %>%  mutate_at(.vars = qc.table.names, change_x)
```

```{r qc-heatmap, fig.width=3, fig.height=10}
# qc heatmap 
cu = brewer.pal(n = 3, "Blues"); cu[1] = "#FFFFFF"
pheatmap(qc_df[, 3:5], 
                   cluster_cols = T, cluster_rows = T,
                   color = cu,width = 2, show_rownames = FALSE)
```

```{r qc-metrics-plot, fig.width=3, fig.height=5}
# tidy
dfp = qc_df %>%
  mutate(uid = paste0(participant_id, "_", array)) %>%
  select(qc.table.names,  matrix, age_imputed, gender, timepoint = time_post_last_vax, uid) %>% 
  gather(metric, value, qc.table.names[1]:qc.table.names[length(qc.table.names)]) %>% 
  group_by( matrix, age_imputed, gender, timepoint, uid, value ) %>% 
  summarize(qcsum = sum(value)) %>% 
  ungroup() %>% 
  mutate(age_imputed = as.numeric(age_imputed)) %>% 
  mutate(SDY = str_sub(matrix, 1,7))

ggplot(dfp, aes(x = SDY, y = qcsum)) +
  theme_bw() + 
  geom_jitter(shape = 21, size = 0.5, width = 0.3, height = 0.3, fill = "blue3") +
  coord_flip() + 
  geom_hline(yintercept = c(0.5, 1.5, 2.5), linetype = "dashed") +
  # xlab("SDY unique Matrix ") + 
  scale_y_continuous(breaks = c(0,1,2,3)) + 
  # ylim(c(0,3)) + 
  ylab("number of QC \n metrics not passed ")  +
  theme(text = element_text(face = "bold"))


```

```{r qc-venn, fig.width=5, fig.height=5}
df.fig.venn <-
  qc_df%>% 
  select(qc.table.names) %>% 
  mutate_if(is.integer, as.numeric) %>% 
  mutate_if(is.logical, as.numeric) 

pdf(file = file.path(figpath, "venn_outlier.pdf"), width = 5, height = 5)
venn::venn(plt, zcolor = "style",
           borders = FALSE, 
           size = 10, 
           cexil = 1.1,
           cexsn = 0.6, 
           ggplot = TRUE) 
dev.off()
venn(df.fig.venn, zcolor = "style",
           borders = FALSE, 
           size = 10, 
           cexil = 1.1,
           cexsn = 0.6, 
           ggplot = TRUE) 
```

### B: 
Proportion of subjects of various self reported race and imputed y chrom values per pathogen*vaccine type
*Authors:* Joanna Arce

Combine the data for a full dataset with all ages
```{r create-pdata}
getPdata <- function(eset){
  pd <- as_tibble(pData(eset))
  pd <- pd %>% dplyr::select(uid, everything())
  pd$age_reported <- as.numeric(pd$age_reported)
  return(pd)
}

pdata_young <- getPdata(young.NoResp)
pdata_old <- getPdata(old.NoResp)

pdata_df <- getPdata(all.noResp)
```

Pre-processing
```{r}
# Remove malaria - why?
pdata_no_malaria <- filter(pdata_df, study_accession != "SDY1293")

# Filter to unique subjects
pdata_df_uniqueSubjects <- distinct(pdata_no_malaria, 
                                    participant_id, 
                                    y_chrom_present, 
                                    race, 
                                    pathogen, 
                                    vaccine_type)

# Create new column for pathogen and vaccine
pdata_df_uniqueSubjects <- mutate(pdata_df_uniqueSubjects, 
                                  pathogen_vacc = paste0(pathogen, "\n(", vaccine_type, ")"))

getCounts <- function(pd, colnm, prefix){
  counts_df <- arrange(dplyr::count(pd, .data[[colnm]], pathogen_vacc), n)
  counts_df$pathogen_total <- sapply(1:nrow(counts_df), function(i){
    return(sum(filter(counts_df, pathogen_vacc == counts_df$pathogen_vacc[i])$n))
  })
  counts_df$pathogen_vacc <- paste0(counts_df$pathogen_vacc, "\nn = ", counts_df$pathogen_total)
  counts_df$n <- counts_df$n/counts_df$pathogen_total
  colnames(counts_df) <- c("category", "pathogen_vacc", "freq")
  counts_df$category <- paste0(prefix, counts_df$category)
  return(counts_df)
}

sex_counts_df <- getCounts(pdata_df_uniqueSubjects, "y_chrom_present", "YCHROM_")
race_counts_df <- getCounts(pdata_df_uniqueSubjects, "race", "RACE_")

total_counts <- rbind(sex_counts_df, race_counts_df)
names(colors.fig1a) <- c(unique(total_counts$pathogen_vacc)[c(2, 11, 3, 12, 8)],
                       "Malaria (Recombinant protein)",
                       unique(total_counts$pathogen_vacc)[c(7, 6, 5, 1, 4, 9, 10)])
```


```{r plot}
p <- ggplot(total_counts) +
  geom_bar(aes(x = freq, y = category, fill = pathogen_vacc), 
           color = "black", stat = "identity", lwd = .2) +
  geom_hline(yintercept = 7.5, color = "grey", lwd = .4) +
  facet_wrap(vars(pathogen_vacc), nrow = 2) +
  scale_y_discrete(limits = rev(c("YCHROM_TRUE", 
                                  "YCHROM_FALSE",
                                  "RACE_White", 
                                  "RACE_Black or African American", 
                                  "RACE_Asian", 
                                  "RACE_American Indian or Alaska Native", 
                                  "RACE_Other", 
                                  "RACE_Not Specified", 
                                  "RACE_Unknown")),
                   labels = rev(c("Male", 
                                  "Female",
                                  "White", 
                                  "Black or African American", 
                                  "Asian", 
                                  "American Indian or Alaska Native", 
                                  "Other", 
                                  "Not Specified", 
                                  "Unknown"))) +
  scale_x_continuous(breaks = c(0, .2, .4, .6, .8, 1), 
                     labels = c(0, 20, 40, 60, 80, 100)) +
  scale_fill_manual(values = colors.fig1a) +
  guides(fill = FALSE) +
  xlab("Distribution (%)") +
  ylab(NULL) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90))

p
```

## Consort diagram

## Figure 2: QC

```{r pca-functions}
getPCAs <- function (eset, maxpc = 3) {
  if (!is.matrix(eset)) {
    ex <- exprs(eset)
    out <- pData(eset)
  }
  else {
    out <- NULL
    ex <- eset
  }
  pca.res <- prcomp(t(ex))
  x <- pca.res$x[, 1:maxpc]
  colnames(x) <- paste("PC", 1:maxpc, sep = ".")
  varex = round(100 * summary(pca.res)$importance[2, ])
  db <- cbind.data.frame(x)
  if (!is.null(out)) 
    db <- cbind(db, out)
  return(list(db = as.data.frame(db), varex = varex))
}
plotPCA<-function(pca.db,title=paste0('PCA'), 
                  color.var='study2',
                  var.shape='pathogen',
                  var.size='months2' ){
  
  p1 <- ggplot(mutate(as.data.frame(pca.db$db),
                      months=round((study_time_collected/28),1),
                      months2=ifelse(months<0, -1, months)+2),
               aes_string(x='PC.1', y='PC.2', color=color.var, shape=var.shape)) +
    geom_jitter() + theme_bw() +
    scale_color_manual(values=getPalette(length(unique(pca.db$db[[color.var]])))) +
    labs(x=paste('PC-1 (',pca.db$varex[1],'%)',sep=''), 
         y=paste('PC-2 (',pca.db$varex[2],'%)',sep=''), title=title) 
  
  return(p1)
}


impute.na<-function(x){x[is.na(x)]<-mean(x,na.rm=T); return(x)}
```
```{r pvca-functions} 

getEigen<-function(eset){
  theDataMatrix <- exprs(eset)
  dataRowN <- nrow(theDataMatrix)
  dataColN <- ncol(theDataMatrix)
  
  theDataMatrixCentered <- matrix(data = 0, nrow = dataRowN, 
                                  ncol = dataColN)
  theDataMatrixCentered_transposed <- apply(theDataMatrix, 
                                            1, scale, center = TRUE, scale = FALSE)
  theDataMatrixCentered <- t(theDataMatrixCentered_transposed)
  theDataCor <- cor(theDataMatrixCentered)
  eigenData <- eigen(theDataCor)
  
  return(eigenData)
}


pvcaBatchAssess.MSF2<-function(eset, eigenData=NULL, batch.factors, threshold, include.inter="all") {
  require(lme4)
  theDataMatrix <- exprs(eset)
  dataRowN <- nrow(theDataMatrix)
  dataColN <- ncol(theDataMatrix)
  
  if (is.null(eigenData)){
    theDataMatrixCentered <- matrix(data = 0, nrow = dataRowN, 
                                    ncol = dataColN)
    theDataMatrixCentered_transposed <- apply(theDataMatrix, 
                                              1, scale, center = TRUE, scale = FALSE)
    theDataMatrixCentered <- t(theDataMatrixCentered_transposed)
    theDataCor <- cor(theDataMatrixCentered)
    eigenData <- eigen(theDataCor)
  }
  
  
  eigenValues <- eigenData$values
  ev_n <- length(eigenValues)
  eigenVectorsMatrix <- eigenData$vectors
  eigenValuesSum <- sum(eigenValues)
  percents_PCs <- eigenValues/eigenValuesSum
  expInfo <- pData(eset)[, batch.factors]
  exp_design <- as.data.frame(expInfo)
  expDesignRowN <- nrow(exp_design)
  expDesignColN <- ncol(exp_design)
  my_counter_2 <- 0
  my_sum_2 <- 1
  for (i in ev_n:1) {
    my_sum_2 = my_sum_2 - percents_PCs[i]
    if ((my_sum_2) <= threshold) {
      my_counter_2 = my_counter_2 + 1
    }
  }
  if (my_counter_2 < 3) {
    pc_n = 3
  }
  else {
    pc_n = my_counter_2
  }
  pc_data_matrix <- matrix(data = 0, nrow = (expDesignRowN * 
                                               pc_n), ncol = 1)
  mycounter = 0
  for (i in 1:pc_n) {
    for (j in 1:expDesignRowN) {
      mycounter <- mycounter + 1
      pc_data_matrix[mycounter, 1] = eigenVectorsMatrix[j, 
                                                        i]
    }
  }
  AAA <- exp_design[rep(1:expDesignRowN, pc_n), ]
  Data <- cbind(AAA, pc_data_matrix)
  variables <- c(colnames(exp_design))
  for (i in 1:length(variables)) {
    Data$variables[i] <- as.factor(Data$variables[i])
  }
  op <- options(warn = (-1))
  model.func <- c()
  index <- 1
  for (i in 1:length(variables)) {
    mod = paste("(1|", variables[i], ")", sep = "")
    model.func[index] = mod
    index = index + 1
  }
  for (i in 1:(length(variables) - 1)) {
    for (j in (i + 1):length(variables)) {
      mod = paste("(1|", variables[i], ":", variables[j], 
                    ")", sep = "")
      model.func[index] = mod
      index = index + 1
    }
  }
  
  if (include.inter!="all"){
    i.delete.RE <- setdiff(grep(":", model.func), grep(include.inter, 
                                                       model.func))
    delete.RE <- model.func[i.delete.RE]
    model.func <- setdiff(model.func, delete.RE)
  }
  
  effects_n = length(model.func) + 1
  randomEffectsMatrix <- matrix(data = 0, nrow = pc_n, ncol = effects_n)
  function.mods <- paste(model.func, collapse = " + ")
  for (i in 1:pc_n) {
    y = (((i - 1) * expDesignRowN) + 1)
    funct <- paste("pc_data_matrix", function.mods, sep = " ~ ")
    Rm1ML <- lmer(funct, Data[y:(((i - 1) * expDesignRowN) + 
                                   expDesignRowN), ], REML = TRUE, verbose = FALSE, 
                  na.action = na.omit)
    randomEffects <- Rm1ML
    randomEffectsMatrix[i, ] <- c(unlist(VarCorr(Rm1ML)), 
                                  resid = sigma(Rm1ML)^2)
  }
  effectsNames <- c(names(getME(Rm1ML, "cnms")), "resid")
  randomEffectsMatrixStdze <- matrix(data = 0, nrow = pc_n, 
                                     ncol = effects_n)
  for (i in 1:pc_n) {
    mySum = sum(randomEffectsMatrix[i, ])
    for (j in 1:effects_n) {
      randomEffectsMatrixStdze[i, j] = randomEffectsMatrix[i, 
                                                           j]/mySum
    }
  }
  randomEffectsMatrixWtProp <- matrix(data = 0, nrow = pc_n, 
                                      ncol = effects_n)
  for (i in 1:pc_n) {
    weight = eigenValues[i]/eigenValuesSum
    for (j in 1:effects_n) {
      randomEffectsMatrixWtProp[i, j] = randomEffectsMatrixStdze[i, 
                                                                 j] * weight
    }
  }
  randomEffectsSums <- matrix(data = 0, nrow = 1, ncol = effects_n)
  randomEffectsSums <- colSums(randomEffectsMatrixWtProp)
  totalSum <- sum(randomEffectsSums)
  randomEffectsMatrixWtAveProp <- matrix(data = 0, nrow = 1, 
                                         ncol = effects_n)
  for (j in 1:effects_n) {
    randomEffectsMatrixWtAveProp[j] = randomEffectsSums[j]/totalSum
  }
  return(list(dat = randomEffectsMatrixWtAveProp, label = effectsNames))
}


plotPVCA <- function(pvcaObj, 
                     cex.percentage = 1, 
                     ht = 4, 
                     wd = 5, 
                     title = fname, 
                     race.vars=NULL,
                     outputDir = NULL) {
  labels <- gsub(":", " x ", pvcaObj$label)
  labels <- gsub("_imputed", " ", labels)
  db <- data.frame(perc = t(pvcaObj$dat), labels = factor(labels, 
                                                          levels = labels))
  
  if (!is.null(race.vars)) {
    db<-rbind(db, 
              data.frame(perc=sum(subset(db, labels%in%race.vars)$perc), labels='race')) %>%
      subset(!(labels%in%race.vars)) %>% arrange(1*(labels=='resid'), perc)
  }
  
  p <- ggplot(db, aes(x = reorder(labels, perc), y = perc)) + 
    geom_bar(stat = "identity", fill = "blue") + theme_bw() + 
    scale_y_continuous(limits = c(0,  1.1)) + 
    geom_text(aes(x = labels, y = perc + 0.05, label = paste0(as.character(round(100 *  perc, 1)), "%"))) +
    labs(x = "Effects", y = "Weighted average proportion variance", title = paste("PVCA ", title)) + 
    scale_x_discrete(labels = function(x) str_wrap(x, width = 8))
  return(p)
}


```
TODO: Add PCA for PBMC and whole blood
- save individual plots and upload those

### A. 
QC metrics

### B. 
PCA - baseline samples before cross-study normalization
```{r pca-nonorm}
all.noNorm$age_group <- ifelse(all.noNorm$age_imputed < 50, "young", "old")
eset_noNorm_baseline <- all.noNorm[, all.noNorm$study_time_collected == 0]

features.pca.0 <- featureNames(eset_noNorm_baseline)[
  which( (rowMeans(is.na(exprs(eset_noNorm_baseline)))==0) &
           (apply(exprs(eset_noNorm_baseline),1,sd)>0) 
  )]

pca_noNorm_cacheFile <- file.path(dataCacheDir, "pca_noNorm.rds")
if (file.exists(pca_noNorm_cacheFile)) {
  pca_noNorm_baseline <- readRDS(pca_noNorm_cacheFile)
} else {
  pca_noNorm_baseline <- getPCAs(eset_noNorm_baseline[features.pca.0,])
  saveRDS(pca_noNorm_baseline, pca_noNorm_cacheFile)
}

pcaPlot_noNorm <-plotPCA(pca_noNorm_baseline,
                         title='PCA Baseline',
                         color.var='study_accession',
                         var.shape='featureSetVendor',
                         var.size=1) +
  scale_shape_manual(values=c(12,20,21:23,10,11,13:19))
```

```{r pvca-nonorm}
batch.vars <- c('cell_type',
                'featureSetVendor',
                'featureSetName2',
                'study_accession', 
                'y_chrom_present')

pvca_noNorm_cacheFile <- file.path(dataCacheDir, "pvca_noNorm.rds")
if (!file.exists(pvca_noNorm_cacheFile)) {

  eigen_noNorm <- getEigen(eset_noNorm_baseline[features.pca.0,])
  
  pvca_noNorm <- pvcaBatchAssess.MSF2(eset_noNorm_baseline[features.pca.0,], 
                                      eigenData = eigen_noNorm,
                                      batch.factors = batch.vars,
                                      include.inter = "none",
                                      threshold = 0.8)
  save(eigen_noNorm, pvca_noNorm, file = pvca_noNorm_cacheFile)
} else {
  load(pvca_noNorm_cacheFile)
}

pvcaPlot_noNorm <- plotPVCA(pvca_noNorm,
                title = "Baseline",
                ht=3,
                wd=6.2, 
                race.vars = NULL,
                outputDir = outputDir) +
  theme(axis.text.x = element_text(angle = 20, hjust = 1))
```

```{r pca-noNorm-plots, fig.width=10, fig.height = 7}
pcaPlot_noNorm + pvcaPlot_noNorm
```

### C. 
PCA - baseline samples after batch correction
```{r pca-norm}
all.noResp$age_group <- ifelse(all.noResp$age_imputed < 50, "young", "old")
eset_norm_baseline <- all.noResp[, all.noResp$study_time_collected == 0]

features.pca.n0 <- featureNames(eset_norm_baseline)[
  which( (rowMeans(is.na(exprs(eset_norm_baseline)))==0) &
           (apply(exprs(eset_norm_baseline),1,sd)>0) 
  )]

pca_norm_cacheFile <- file.path(dataCacheDir, "pca_norm.rds")
if (file.exists(pca_norm_cacheFile)) {
  pca_norm_baseline <- readRDS(pca_norm_cacheFile)
} else {
  pca_norm_baseline <- getPCAs(eset_norm_baseline[features.pca.n0, ])
  saveRDS(pca_norm_baseline, pca_norm_cacheFile)
}

pcaPlot_norm <-plotPCA(pca_norm_baseline,
                         title='PCA Baseline',
                         color.var='study_accession',
                         var.shape='featureSetVendor',
                         var.size=1) +
  scale_shape_manual(values=c(12,20,21:23,10,11,13:19))
```

```{r pvca-norm}
pvca_norm_cacheFile <- file.path(dataCacheDir, "pvca_norm.rds")
if (!file.exists(pvca_norm_cacheFile)) {

  eigen_norm <- getEigen(eset_norm_baseline[features.pca.n0,])
  
  pvca_norm <- pvcaBatchAssess.MSF2(eset_norm_baseline[features.pca.n0,], 
                                      eigenData = eigen_norm,
                                      batch.factors = batch.vars,
                                      include.inter = "none",
                                      threshold = 0.8)
  save(eigen_norm, pvca_norm, file = pvca_norm_cacheFile)
} else {
  load(pvca_norm_cacheFile)
}

pvcaPlot_norm <- plotPVCA(pvca_norm,
                title = "Baseline",
                ht=3,
                wd=6.2, 
                race.vars = NULL,
                outputDir = outputDir) +
  theme(axis.text.x = element_text(angle = 20, hjust = 1))
```

```{r pca-norm-plots, fig.width=10, fig.height = 7}
pcaPlot_norm + pvcaPlot_norm
```
### D.
y_chrom expression by timepoint (TODO) -- Bram: check his code

### E. 
raptor age imputed (young)
```{r get-raptor-test-results}
get_raptor_results <- function(eset) {
  library(RAPToR)
  raptor_function <- "X ~ s(age_reported, bs = 'cr') + matrix"
  raptor_eset <- eset[, eset$time_post_last_vax == 0]
  p <- pData(raptor_eset)
  X <- exprs(raptor_eset)
  
  # Choose which samples to use for reference dataset:
  studies_without_ages <- c("SDY1260", "SDY1264","SDY1293","SDY1294","SDY1364","SDY1370","SDY1373","SDY984")
  
  test_sample_indices <- which(p$study_accession %in% studies_without_ages)
  ref_sample_indices <- which(!p$study_accession %in% studies_without_ages)
  
  # Make test sets:
  p_test <- p[test_sample_indices,]
  p <- p[ref_sample_indices,]
  
  X <- X[!missing_indices,]
  X_test <- X[,test_sample_indices]
  X <- X[,ref_sample_indices]
  
  
  # Number of components
  pca <- stats::prcomp(X, rank = 20)
  nc <- sum(summary(pca)$importance[3, ] < .999) + 1 # Number of significant components
  
  # Build Model:
  funct <- raptor_function
  m <- ge_im(X = X, p = p, formula = funct, nc = nc)
  
  # Build interpolation data
  n.inter = 500
  ndat <- data.frame(
    age_reported = seq(min(p$age_reported),
                       max(p$age_reported), l = n.inter),
    arm_accession = sample(unique(p$arm_accession), n.inter, replace = TRUE), 
    y_chrom_present = sample(c(TRUE, FALSE), n.inter, replace = TRUE),
    matrix = sample(unique(p$matrix),n.inter,replace = TRUE),
    study_accession = sample(unique(p$study_accession),n.inter,replace = TRUE),
    race = sample(unique(p$race), n.inter, replace = TRUE),
    ethnicity = sample(unique(p$ethnicity), n.inter, replace = TRUE),
    cohort = sample(unique(p$cohort),n.inter,replace = TRUE)
  )
  
  # get interpolated GE matrix, as a reference
  r_X <- list(interpGE = stats::predict(m, ndat), time.series = ndat$age_reported)
  
  # test
  ae_X <- ae(X, r_X$interpGE, r_X$time.series)
  
  # Get regression:
  results <- tibble(actual = p$age_reported, estimates = ae_X$age.estimates[,1])
  return(results)
}
```

```{r raptor-young}
raptor_young_cacheFile <- file.path(dataCacheDir, "raptor_young_result.rds")
if (file.exists(raptor_young_cacheFile)) {
  results_young <- readRDS(raptor_young_cacheFile)
} else {
  results_young <- get_raptor_results(young.NoResp)
  saveRDS(results_young, raptor_young_cacheFile)
}
lm_fit_young <- lm(actual ~ estimates, data=results_young)
# Plot:
ggplot(results_young) +
  geom_point(aes(x = actual, y = estimates)) +
  geom_smooth(aes(x = actual, y = actual), method='lm') +
  xlab("age_reported") +
  ylab("estimated age (from RAPToR)") +
  xlim(18, 50) +
  ylim(18, 50) +
  ggtitle(paste0("RAPToR Prediction vs. Actual Age: R^2 = ", round(summary(lm_fit_young)$r.squared, 3)))

```



### F. 
raptor age imputed (old)

```{r raptor-old}
raptor_old_cacheFile <- file.path(dataCacheDir, "raptor_old_result.rds")
if (file.exists(raptor_old_cacheFile)) {
  results_old <- readRDS(raptor_old_cacheFile)
} else {
  results_old <- get_raptor_results(old.NoResp)
  saveRDS(results_old, raptor_old_cacheFile)
}
lm_fit_old <- lm(actual ~ estimates, data=results_old)
# Plot:
ggplot(results_old) +
  geom_point(aes(x = actual, y = estimates)) +
  geom_smooth(aes(x = actual, y = actual), method='lm') +
  xlab("age_reported") +
  ylab("estimated age (from RAPToR)") +
  xlim(50, 90) +
  ylim(50, 90) +
  ggtitle(paste0("RAPToR Prediction vs. Actual Age: R^2 = ", round(summary(lm_fit_old)$r.squared, 3)))

```

### G. 


## Figure 3
Overview HIPC Signatures Transcriptomics Data Compilation (young and old). 

### A. 
Number of samples (check again) are summarized in transcriptomics (TX), hemaglutination inhibition assay (HAI), neutralizing antibody assay (NAB) and ELISA assays (ELISA) 

(TODO)

### B. 

Venn diagram: Each area- proportional Euler diagram represents the total number of participants with corresponding data types.

(TODO)

### C.
Box plot corresponds to the participants age per pathogen and vaccine type. Individual colors signifies the vaccine type each participants received while the shape of the point represents the sex of the participants. Imputation on sex based on Y chromosome genes was performed on participants with potential misassignment while age imputations were performed on datasets with missing age information (SDY......). 
*Author: * Slim Fourati
```{r, fig-1c, fig.width=6.8, fig.height=7}
df.fig1c <- pData(young.NoResp) %>%
  select(participant_id, pathogen, vaccine_type, age_imputed, y_chrom_present) %>%
  distinct() %>%
  mutate(vaccine = paste0(pathogen, " (", vaccine_type, ")"))

# remove vaccine where all the participant have the same age
flag <- df.fig1c %>%
  group_by(vaccine) %>%
  summarize(nbUniqueAge = length(unique(age_imputed))) %>%
  filter(nbUniqueAge > 1)

df.fig1c <- filter(df.fig1c, vaccine %in% flag$vaccine)

ggplot(data = df.fig1c,
       mapping = aes(x = vaccine,
		                 y = age_imputed)) +
  geom_boxplot(fill = "transparent", outlier.color = "transparent") +
  geom_beeswarm(mapping = aes(color = vaccine, shape = y_chrom_present),
		            cex = 0.3) +
  scale_color_manual(name   = "Pathogen (Vaccine type)",
                     values = vaccine2color) +
  labs(x = "Pathogen (Vaccine type)", y = "Age") + 
  theme_bw() +
  theme(panel.grid         = element_blank(),
      	panel.grid.major.y = element_line(color = "lightgrey"),
      	axis.text          = element_text(color = "black"),
      	axis.text.x        = element_text(angle = 45, hjust = 1, size = 8),
      	legend.text        = element_text(size = 7),
      	legend.key.height  = unit(0.02, units = "npc"),
      	legend.key.width   = unit(0.015, units = "npc")) +
  guides(fill = guide_legend(ncol = 1))

# test for difference between vaccine
kruskal.test(formula = age_imputed ~ vaccine, data = df.fig1c)
```

### D: 
Plot number of samples as a function of day of sampling
TODO: Which dataset to use for this? (all vs young)
*Authors:* Slim Fourati, Joanna Arce
```{r, fig-1b, fig.width=6.29, fig.height=4.84}
# any sampling data after 20 days coded as >20
df.fig1b <- pData(young.NoResp) %>%
  select(uid, study_time_collected, pathogen, vaccine_type) %>%
  arrange(study_time_collected) %>%
  mutate(study_time_collected = signif(study_time_collected, digits = 3),
	 study_time_collected.factor = ifelse(test = study_time_collected > 20,
					      yes  = ">20",
					      no   = study_time_collected),
	 study_time_collected.factor =
	   factor(study_time_collected.factor,
		  levels = unique(study_time_collected.factor)),
	 vaccine = paste0(pathogen, " (", vaccine_type, ")")) %>%
  group_by(study_time_collected.factor, vaccine) %>%
  summarize(n = n())

ggplot(data = df.fig1b,
       mapping = aes(x = study_time_collected.factor,
		                 y = n)) +
  geom_bar(stat = "identity", mapping = aes(fill = vaccine)) +
  labs(x = "Days post-vaccination", y = "Number of samples") +
  scale_y_continuous(limits = c(0, 800),
		                 breaks = seq(from = 0, to = 800, by = 100)) + 
  scale_fill_manual(name   = "Pathogen (Vaccine type)",
		                values = vaccine2color) +
  theme_bw() +
  theme(panel.grid         = element_blank(),
      	panel.grid.major.y = element_line(color = "lightgrey"),
      	axis.text          = element_text(color = "black"),
      	axis.text.x        = element_text(angle = 45, hjust = 1),
      	legend.pos         = "bottom",
      	legend.text        = element_text(size = 7),
      	legend.key.height  = unit(0.02, units = "npc"),
      	legend.key.width   = unit(0.015, units = "npc")) +
  guides(fill = guide_legend(ncol = 2))
```

### E: 
Number of samples as a function of pathogen and vaccine type
TODO: Which dataset to use for this? Do we want number of samples or number of participants? 

```{r}
# any sampling data after 20 days coded as >20
df.fig3e <- pData(all.noResp) %>%
  select(participant_id, pathogen, vaccine_type) %>%
  mutate(vaccine = paste0(pathogen, " (", vaccine_type, ")")) %>%
  group_by(participant_id, vaccine) %>%
  summarize(n = n()) %>%
  group_by(vaccine) %>%
  summarize(n = n())

ggplot(data = df.fig3e, 
       mapping = aes(x = vaccine, y = n)) +
  geom_bar(stat = "identity", mapping = aes(fill = vaccine)) + 
  labs(x = "Pathogen (Vaccine Type)", y = "Number of Participants") + 
  scale_fill_manual(values = vaccine2color) +
  theme_bw() + 
  theme(panel.grid         = element_blank(),
        panel.grid.major.y = element_line(color = "lightgrey"),
        axis.text          = element_text(color = "black"),
        axis.text.x        = element_text(angle = 45, hjust = 1),
        legend.pos         = "none",
        legend.text        = element_text(size = 7),
        legend.key.height  = unit(0.02, units = "npc"),
        legend.key.width   = unit(0.015, units = "npc"))
```

## Figure 4

### A: 
Summary of Pathogen (Vaccine Type) for Immune Response
TODO: Which dataset to use for this? Do we want number of samples or number of participants? 
```{r}
# any sampling data after 20 days coded as >20
df.fig4a <- pData(young.WithResp) %>%
  select(uid, pathogen, vaccine_type, assay) %>%
  unique() %>%
  mutate(
    assay = vapply(assay, FUN= switch, FUN.VALUE = "hai",
                   hai = "HAI", 
                   elisa = "ELISA",
                   neut_ab_titer = "NAB"),
    vaccine = paste0(pathogen, " (", vaccine_type, ")")) %>%
  group_by(vaccine, assay) %>%
  summarize(n = n())

ggplot(data = df.fig4a, 
       mapping = aes(x = assay, y = n)) +
  geom_bar(stat = "identity", mapping = aes(fill = vaccine)) + 
  labs(x = "Immune Response Assay", y = "Number of Participants") + 
  scale_fill_manual(values = vaccine2color, 
                    name = "Pathogen (Vaccine Type)") +
  theme_bw() + 
   theme(panel.grid         = element_blank(),
      	panel.grid.major.y = element_line(color = "lightgrey"),
      	axis.text          = element_text(color = "black"),
      	legend.pos         = "bottom",
      	legend.text        = element_text(size = 7),
      	legend.key.height  = unit(0.02, units = "npc"),
      	legend.key.width   = unit(0.015, units = "npc")) +
  guides(fill = guide_legend(ncol = 2))
```

### B.  
TODO  
### C.  
TODO  
### D.  
TODO  

---
# Where do these go?

### Figure 1d: Proportion of Variance Explained
<!-- TODO: Where does this go?  -->
*Author: * Slim Fourati
```{r, fig-1d-data-prep}
em.fig1d <- exprs(young.NoResp)
pd.fig1d <- pData(young.NoResp) %>%
  mutate(Vaccine = paste0(pathogen, " (", vaccine_type, ")")) %>%
  select(y_chrom_present, ethnicity, Vaccine, study_time_collected,
	 age_imputed) %>%
  rename(
    Ychrom = y_chrom_present, 
    Ethnicity = ethnicity,
    Timepoint = study_time_collected,
    Age       = age_imputed) 
pd.fig1d <- pd.fig1d[colnames(em.fig1d), ]
```

```{r, fig-1d-PVCA, echo=FALSE}
pvcaCacheFile <- file.path(dataCacheDir, "pvca.rds")
if(!file.exists(pvcaCacheFile)){
  fit <- PVCA(counts    = em.fig1d,
              meta      = pd.fig1d,
              threshold = 0.6,
              inter     = FALSE)
  saveRDS(fit, pvcaCacheFile)
}else{
  fit <- readRDS(pvcaCacheFile)
}

```

```{r, fig-1d-plot, fig.width=4, fig.height=7}
df.fig1d <- data.frame(explained = as.vector(fit),
                       effect    = names(fit)) %>%
  arrange(explained) %>%
  mutate(effect = factor(effect, levels = effect))

ggplot(data    = df.fig1d,
       mapping = aes(x = effect, y = explained)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = signif(explained, digits = 3)),
            nudge_y   = 0.01,
            size      = 3) +
  labs(x = NULL, y = "Proportion of the variance explained") + 
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90,
                                   vjust = 0.5,
                                   hjust = 1))
```

